//Copyright 2002 United States Geological Survey
//Released under GPL with MapIMG copyright 2003 USGS

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MapIMG GUI
// Uses: MapIMG -- written by D. Steinwand
//          GCTP20 -- released August 98, customized by S. Posch Aug 2002
// Portions of the underlying code were generated by QT Designer
//
// Programmer: Stephan Posch, Student Programmer, USGS
// Date: 8/2002
// Modified: Jason Trent, Student Porgrammer, USGS  7/03
//           Now uses templated MapIMG to allow for multiple data types
//           Also, loads projection from .info if found
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// C Libraries
#include <ctype.h>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <time.h>

// QT Libraries
#include <qfiledialog.h>		// QT File Dialogs
#include <qstring.h>			// QT String class
#include <qmessagebox.h>		// QT Message Boxes
#include <qfile.h>                      // QT File I/O
#include <qdir.h>                       // QT Directory I/O
#include <qsettings.h>                  // QT Settings Manipulation
#include <qtimer.h>                     // QT Timers
#include <qpopupmenu.h>                 //QT Popup Menu

// MapIMG Libraries
#include "getprojinfo.h"
#include "imgio.h"
#include "projInfo.h"
#include "tiff2img.h"
#include "version.h"
#include "qembed_images.h"

// Dialog Libraries
#include "sineForm.h"
#include "equirectForm.h"
#include "vanderForm.h"
#include "interruptForm.h"
#include "stereoForm.h"
#include "genVertForm.h"
#include "oblatedForm.h"
#include "intsineForm.h"
#include "lambForm.h"
#include "mercForm.h"
#include "psForm.h"
#include "pcForm.h"
#include "ecaForm.h"
#include "tmercForm.h"
#include "homaForm.h"
#include "hombForm.h"
#include "somaForm.h"
#include "sombForm.h"
#include "acForm.h"
#include "utmForm.h"
#include "projfileForm.h"
#include "window_flags.h"
#include "aboutform.h"

//default extension used when opening and saving files
QString defaultExtension = ".img";

// Bring in proj.h as a "C" header file
extern "C"
{
	#include "proj.h"
}

// Okay button execution
void mapimgForm::executemapimg()
{
    srand( (unsigned)time( NULL ) );    // Seed Random Number Generator

    long outputRows = 0;
    long outputCols = 0;

    int georeturnval;					// Return value from geo2eqr()
    int mapframereturnval, mapframereturnval2;		// Return values from mapframit()

    QString bitSelection = inputDataTypeComboBox->currentText();
    QString existcheck = outFilenameEdit->text();
    int checkans = 0;

    // if projection hasn't been chosen, make one be chosen
    int index = projectionComboBox->currentItem();
    int index2 = pixelComboBox->currentItem();

    if( !QFile::exists( inFilenameEdit->text() )  )
    {
	QMessageBox::information(this, "Aborted!","Please Select an Input File First!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	inputProjectionComboBox->setCurrentItem(0);
    }
    else if( inputDataTypeComboBox->currentItem() < 2 )
    {
	QMessageBox::information(this, "Aborted!","Please Select an Input Data Type",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	inputDataTypeComboBox->setCurrentItem(0);
    }
    else if( inputProjectionComboBox->currentItem() < 2 )
    {
	QMessageBox::information(this, "Aborted!","Please Select an Input Projection",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	inputProjectionComboBox->setCurrentItem(0);
    }
    else if( outFilenameEdit->text() == "" )
    {
	QMessageBox::information(this, "Aborted!","Please Select an Output File First!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	projectionComboBox->setCurrentItem(0);
    }
    else if(index < 2)
    {
	QMessageBox::information (this, "Aborted!","Please Select an Output Projection",
					 QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	projectionComboBox->setCurrentItem(0);
    }

    // if pixel size hasn't been chosen, make one be chosen
    else if(index2 < 2)
    {
	QMessageBox::information (this, "Aborted!","Please Select a Pixel Size",
					 QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	pixelComboBox->setCurrentItem(0);
    }

    // otherwise, proceed with projection transformation
    else
    {
	              // Disable MapIMG dialog
		this->setDisabled(true);

		// if output file already exists, ask about overwrite
		if(QFile::exists(existcheck))
		checkans = QMessageBox::warning(this, "MapIMG -- Overwrite File",
			      QString( "Overwrite -- Process is Not Reversable\n\'%1\'?" ).
                                              arg( existcheck ),
                                               "&Yes", "&No", QString::null, 1, 1 );

		// if answer is yes, remove the existing generic binary and .info files
		if(checkans == 0)
		{
		        QString infodelete = outfilepath + ".info";
			remove(existcheck);
			remove(infodelete);
			outfilepath = existcheck;
			outFilenameEdit->setText(existcheck);
		}
		// otherwise, reset the fields and abort
		else
		{
			outfilepath.truncate(0);
			outFilenameEdit->clear();
			return;
		}

                //logFile is defined in getprojinfo.h it is where the log is stored
                //delete it at the start of the projection if it already exists
                if( QFile::exists( logFile ) )
                {
                    QFile::remove( logFile );
                }

		FILE * project;			// file pointer for .proj file

		// Create and edit .proj file
		int random = rand();
		char mitemp[20];
		char mitemp2[20];
		char mitempproj[20];
		char mitemp2proj[20];
		strncpy(mitemp, "mitemp",20);
		strncpy(mitemp2, "mitemp",20);

		QString qrandom;
		qrandom.setNum(random);

		strncat(mitemp, qrandom,20);
		strncpy(mitempproj, mitemp,20);
		strncat(mitempproj, ".proj",20);

		project = fopen(mitempproj, "w");

		// Projection code chosen based on position in Combo Box (output projection)
		if(index < 9)
		{
		    fprintf(project, "%d\n", index-1);
		}
		else if(index == 9 || index == 10)
		{
		    fprintf(project, "8\n");
		}
		else if(index < 22)
		{
		    fprintf(project, "%d\n", index-2);
		}
		else if(index == 22 || index == 23)
		{
		    fprintf(project, "20\n");
		}
		else if(index ==24)
		{
		    fprintf(project, "21\n");
		}
		else if(index == 25 || index == 26)
		{
		     fprintf(project, "22\n");
		}
		else
		{
		      fprintf(project, "%d\n", index - 4);
		}
		fprintf(project, "%d\n", oututmzone);
		fprintf(project, "2\n");
		fprintf(project, "19\n");
		fprintf(project, "%f", output_gctparray[0]);

		for(int k = 1; k < 15; k++)
		{
		    fprintf(project, " %f", output_gctparray[k]);
		}
		fclose(project);

		// get input filename from edit box and convert to 2 char arrays
		// append ".info" to infilename and pass to geo2eqr
		// mapimginfilename will be used in mapimg
		QString infile = infilepath;
		QString infilename = infile + ".info";
		QString mapimginfilename = infile;

		// get input file projection type
		int inputproj = inputProjectionComboBox->currentItem();
		int inprojnum;
		if(inputproj < 10)
		{
		    inprojnum =  inputproj-2;
		}
		else if(inputproj == 10 || inputproj == 11)
		{
		    inprojnum = 8;
		}
		else if(inputproj < 23)
		{
		    inprojnum = inputproj - 3;
		}
		else if(inputproj == 23 || inputproj == 24)
		{
		    inprojnum = 20;
		}
		else if(inputproj ==25)
		{
		    inprojnum = 21;
		}
		else if(inputproj == 26 || inputproj == 27)
		{
		    inprojnum = 22;
		}
		else
		{
		     inprojnum = inputproj - 5;
		}


		// Convert lats and lons to doubles
		double ul_lat = 90.0;
		double ul_lon = -180.0;
		double lr_lat = -90.0;
		double lr_lon = 180.0;

/*		double ul_lat = ul_latEdit->text().toDouble();
		double ul_lon = ul_lonEdit->text().toDouble();
		double lr_lat = lr_latEdit->text().toDouble();
		double lr_lon = lr_lonEdit->text().toDouble();
*/
		// if "other" was chosen for pixel size, get the information
		if(pixelComboBox->currentItem() == 7)
		{
			QString pixelSize_string = pixelEdit->text();
			pixelSize = pixelSize_string.toDouble();
		}

		// if input projection is equirectangular, call geo2eqr
		if(inprojnum == 0)
		{
			// get input file's number of Rows and Cols from Spin Boxes
			int numRows = numRowsSpin->value();
			int numCols = numColsSpin->value();

                       	// Call geo2eqr to generate input file .info file
			georeturnval =  geo2eqr(numRows, numCols, infilename.ascii(), 17);

			// If geo2eqr exited abnormally, delete files and return
			if(!georeturnval)
			{
			   remove(mitempproj);
			   this->setEnabled(true);
			   return;
			}
		}

		// owtherwise, if the .info file doesn't exist, call mapframit to create it (for input projection)
		else if( !QFile::exists(infilename) )
		{
                	FILE * check;
                        srand( (unsigned)time( NULL ) );    // Seed Random Number Generator
                      	int random2 = rand();

			QString qrandom2;
			qrandom2.setNum(random2);

			strncat(mitemp2, qrandom2,20);
			strncpy(mitemp2proj, mitemp2,20);
			strncat(mitemp2proj, ".proj",20);

		        check = fopen(mitemp2proj, "w");
			fprintf(check, "%d\n", inprojnum);
			fprintf(check, "%d\n", inutmzone);
			fprintf(check, "2\n");
			fprintf(check, "19\n");
			fprintf(check, "%f", input_gctparray[0]);
			for(int k = 1; k < 15; k++)
			{
			    fprintf(check, " %f", input_gctparray[k]);
			}
			fclose(check);

			projfileForm* projform;
			projform = new projfileForm(0,0,true, WINDOW_FLAGS);
			connect(projform, SIGNAL(changesMade(double)), this, SLOT(setInPixel(double)));
			projform->exec();
			delete projform;

			mapframereturnval2 = mapframeit(mitemp2, inPixelSize,
						ul_lat, ul_lon, lr_lat, lr_lon, infilename, &outputRows, &outputCols);

			// if mapframit returns abnormally, remove .proj files and .info file and exit process
			if(!mapframereturnval2)
			{
			        remove(mitempproj);
				remove(mitemp2proj);
				remove(infilename);
				this->setEnabled(true);
				return;
			}
		 }

                 // add Data Type to .info so user will not have to manually set
 	         QFile qfAddInputDataType( infilename );
	         QString bitInfo = bitSelection;
                 qfAddInputDataType.open( IO_WriteOnly | IO_Append );
                 qfAddInputDataType.writeBlock( bitInfo.prepend('\n').ascii(), bitInfo.length() +1 );
                 qfAddInputDataType.close();


		// get output filename from edit box and convert to 2 char arrays
		// append .info to outfilename and pass to mapframeit
		// mapimgoutfilename will be used in mapimg
		QString outfile = outfilepath;


		// Abort transformation if input and output files are the same
		if(outfile == infile)
		{
		   QMessageBox::critical (this, "Aborted!","Input and Output Files Must be Different!",
					QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);

		   remove(mitempproj);
		   remove(mitemp2proj);
		   this->setEnabled(true);
		   return;
		}

		QString outfilename = outfile + ".info";
		QString mapimgoutfilename = outfile;

                // Call mapframeit to generate new .info file

		mapframereturnval = mapframeit(mitemp, pixelSize, ul_lat, ul_lon, lr_lat, lr_lon,
					       outfilename, &outputRows, &outputCols);


		// If mapframeit exited abnormally, delete created files and exit process

		if(!mapframereturnval)
		{
			remove(mitempproj);
			remove(mitemp2proj);
			remove(infilename);
			this->setEnabled(true);
			return;
		}

		//get the fill value from the fillval Spin box
		long fillval = fillvalSpin->value();
		// CALL MAPIMG TO DO THE REPROJECTION

                //bitSelection is the text value of the Data Type selection combobox
                //the type needed is initialized and used with the templated mapimg()
                //thus executing with the required data type
                bool cancelled = false;

                if( bitSelection == "Unsigned 8 Bit" )
                {
                	unsigned char ucType = 'U';
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, ucType );
                }
                else if( bitSelection == "Signed 8 Bit" )
                {
                	signed char scType = 'S';
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, scType );
                }
                else if( bitSelection == "Unsigned 16 Bit" )
                {
                	unsigned short usType = 0;
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, usType );
                }
                else if( bitSelection == "Signed 16 Bit" )
                {
                	short sType = 0;
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, sType );
                }
                else if( bitSelection == "IEEE 32 Bit Float" )
                {
                	float fType = 0.0;
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, fType );
                }
                else if( bitSelection == "Unsigned 32 Bit" )
                {
                	unsigned int uiType = 0;
      	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, uiType );
                }
                else if( bitSelection == "Signed 32 Bit" )
                {
               	        int iType = 0;
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, iType );
                }
                else if( bitSelection == "IEEE 64 Bit Float" )
                {
                	double dType = 0.0;
     	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, dType );
                }
                else
                {
                	unsigned char ucType = 'U';
       	                cancelled = mapimg(mapimginfilename.ascii(), mapimgoutfilename.ascii(), fillval, outfilename.ascii(), this,
		             outputRows, outputCols, ucType );
                }


                QFile qfAddProjDataType( outfilename );
                QString qsAddBitInfo = bitSelection;
                qfAddProjDataType.open( IO_WriteOnly | IO_Append );
                qfAddProjDataType.writeBlock( qsAddBitInfo.prepend('\n').ascii(), qsAddBitInfo.length() +1 );
                qfAddProjDataType.close();


		// END MAPIMG

		// Remove unneeded files generated during execution
		remove(mitempproj);
		remove(mitemp2proj);
		remove( logFile );

                //if dialog was not cancelled
                if( !cancelled )
                {
		    // If Clear Checked, Clear All
		    if(clearRadio->isChecked())
      	            {
                       //reset parameter array
                       for( int i = 0; i < 15; i++)
                       {
                            input_gctparray[i] = 0.0;
                            output_gctparray[i] = 0.0;
                       }

		       // Reset the dialog
                       inputDataTypeComboBox->setEnabled( true );
                       showAllDataTypes();
		       inputDataTypeComboBox->setCurrentItem(0);
                       inputProjectionComboBox->setEnabled( true );
		       inputProjectionComboBox->setCurrentItem(0);
		       numRowsSpin->setDisabled(true);
		       numColsSpin->setDisabled(true);
		       numRowsSpin->setValue(0);
		       numColsSpin->setValue(0);

		       // Reset filenames and pixel box
		       inFilenameEdit->clear();
		       infilepath.truncate(0);
		   }

		   // If Move Output Checked
		   if(moveOutputRadio->isChecked())
		   {
                      //move parameter array
                      for( int i = 0; i < 15; i++)
                      {
                           input_gctparray[i] = output_gctparray[i];
                           output_gctparray[i] = 0.0;
                      }

                      QString outputInfoFile = outFilenameEdit->text();
                      loadInputInfo( outputInfoFile );

		      infilepath = inFilenameEdit->text();

                      projectionComboBox->setCurrentItem(0);
		      pixelComboBox->setCurrentItem(0);
		      outFilenameEdit->clear();
		      pixelEdit->clear();
		      outfilepath.truncate(0);

		   }
                   else  //just clear output
                   {
                      //clear output parameter array
                      for( int i = 0; i < 15; i++)
                      {
                         output_gctparray[i] = 0.0;
                      }
                    
                      projectionComboBox->setCurrentItem(0);
		      pixelComboBox->setCurrentItem(0);
		      outFilenameEdit->clear();
		      pixelEdit->clear();
		      outfilepath.truncate(0);
                    }
		}
                // Re-enable the Dialog
		this->setEnabled(true);
	}
}

// Function to check output projection Combo Box
void mapimgForm::comboCheck()
{
    if(outfilepath == "" || outfilepath == " " || outfilepath == NULL)
    {
	QMessageBox::information(this, "Aborted!","Please Select an Output File First!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	projectionComboBox->setCurrentItem(0);
    }

    else
    {
	// get projection Combo Box index
	int index = projectionComboBox->currentItem();

	if(!outfilenameExist())
	{
		switch(index)
		{
		// No projection Chosen
		case 0:
		case 1:
			projectionComboBox->setCurrentItem(0);
			break;

		// UTM, State Plane, Lambert Conformal Conic
//		case 2:
		case 3:
		case 5:
		case 12:
		case 15:
			QMessageBox::information(this, "Sorry","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);

			projectionComboBox->setCurrentItem(0);
			break;
               case 2:
			utmForm * utmform;
			utmform = new utmForm(0,0,true,WINDOW_FLAGS);
			connect(utmform, SIGNAL(changesMade(double *, int)), this, SLOT(setUTMout(double *, int)));
			utmform->exec();
			delete utmform;
			break;

		 // Albers Equal Area, (Lambert Conformal Conic), Equidistant Conic B
//                case 5:
		case 4:
		case 10:
			lambForm * lambform;
			lambform = new lambForm(0,0,true,WINDOW_FLAGS);
			connect(lambform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        lambform->getGCTP();
			connect(lambform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			lambform->exec();
			delete lambform;
			if( index == 10)
			{
			    output_gctparray[8] = 1;
			}
			break;

		 // Mercator
		case 6:
			mercForm * mercform;
			mercform = new mercForm(0,0,true,WINDOW_FLAGS);
			connect(mercform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        mercform->getGCTP();
                        connect(mercform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			mercform->exec();
			delete mercform;
			break;

		// Polar Steroegraphic
		case 7:
			QMessageBox::information(this, "Sorry","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);

			projectionComboBox->setCurrentItem(0);

/*			psForm * psform;
			psform = new psForm(0,0,true,WINDOW_FLAGS);
			connect(psform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			psform->exec();
			delete psform;
*/			break;

		 // Polyconic
		case 8:
			pcForm * pcform;
			pcform = new pcForm(0,0,true,WINDOW_FLAGS);
			connect(pcform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        pcform->getGCTP();
			connect(pcform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			pcform->exec();
			delete pcform;
			break;

		 // Equidistant Conic A
		case 9:
			ecaForm * ecaform;
			ecaform = new ecaForm(0,0,true,WINDOW_FLAGS);
			connect(ecaform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        ecaform->getGCTP();
			connect(ecaform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			ecaform->exec();
			delete ecaform;
			break;

		 // Transverse Mercator
		case 11:
			tmercForm * tmercform;
			tmercform = new tmercForm(0,0,true,WINDOW_FLAGS);
			connect(tmercform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        tmercform->getGCTP();
			connect(tmercform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			tmercform->exec();
			delete tmercform;
			break;

		 // (Stereographic), Lambert Azimuthal, Azimuthal, (Gnomonic), Orthographic
//		case 12:
		case 13:
		case 14:
//		case 15:
		case 16:
			stereoForm * sterform;
			sterform = new stereoForm(0,0,true,WINDOW_FLAGS);
			connect(sterform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        sterform->getGCTP();
			connect(sterform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			sterform->exec();
			delete sterform;
			break;

		 // Gen. Vert. Near Per
		case 17:
			genVertForm * genform;
			genform = new genVertForm(0,0,true,WINDOW_FLAGS);
			connect(genform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        genform->getGCTP();
			connect(genform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArrayOut(double *)));
			genform->exec();
			delete genform;
			break;

		 // Sinusoidal, Miller Cylindrical, Robinson, Mollweide, Hammer, Wagner IV, Wagner VII
		case 18:
		case 20:
		case 24:
		case 29:
		case 31:
		case 32:
		case 33:
			sineForm * sineform;
			sineform = new sineForm(0,0,true,WINDOW_FLAGS);
			connect(sineform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        sineform->getGCTP();
                        connect(sineform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			sineform->exec();
			delete sineform;
			break;

		 // Equirectangular
		case 19:
			equirectForm * equiform;
			equiform = new equirectForm(0,0,true,WINDOW_FLAGS);
			connect(equiform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        equiform->getGCTP();
			connect(equiform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			equiform->exec();
			delete equiform;
			break;

		 // Van der Grinten
		case 21:
			vanderForm * vandform;
			vandform = new vanderForm(0,0,true,WINDOW_FLAGS);
			connect(vandform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        vandform->getGCTP();
			connect(vandform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			vandform->exec();
			delete vandform;
			break;

		 // Hotin Oblique Mercator A
		case 22:
			homaForm * homaform;
			homaform = new homaForm(0,0,true,WINDOW_FLAGS);
			connect(homaform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        homaform->getGCTP();
			connect(homaform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			homaform->exec();
			delete homaform;
			break;

		 // Hotin Oblique Mercator B
		case 23:
			hombForm * hombform;
			hombform = new hombForm(0,0,true,WINDOW_FLAGS);
			connect(hombform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        hombform->getGCTP();
                        connect(hombform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			hombform->exec();
			delete hombform;
			break;

		 // Space Oblique Mercator A
		case 25:
			somaForm * somaform;
			somaform = new somaForm(0,0,true,WINDOW_FLAGS);
			connect(somaform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        somaform->getGCTP();
			connect(somaform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			somaform->exec();
			delete somaform;
			break;

		 // Space Oblique Mercator B
		case 26:
			sombForm * sombform;
			sombform = new sombForm(0,0,true,WINDOW_FLAGS);
			connect(sombform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        sombform->getGCTP();
			connect(sombform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			sombform->exec();
			delete sombform;
			break;

		 // Alaska Conformal
		case 27:
			QMessageBox::information(this, "Sorry","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);

			projectionComboBox->setCurrentItem(0);

/*			acForm * acform;
			acform = new acForm(0,0,true,WINDOW_FLAGS);
			connect(acform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			acform->exec();
			delete acform;
*/			break;

		 // Interrupted Goode, Interrupted Mollweide
		case 28:
		case 30:
			interruptForm * interform;
			interform = new interruptForm(0,0,true,WINDOW_FLAGS);
			connect(interform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        interform->getGCTP();
			connect(interform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			interform->exec();
			delete interform;
			break;

		 // Oblated Equal Area
		case 34:
			oblatedForm * oblform;
			oblform = new oblatedForm(0,0,true,WINDOW_FLAGS);
			connect(oblform, SIGNAL(getGCTP(double*)), this, SLOT(getOutputGCTP(double*)));
                        oblform->getGCTP();
			connect(oblform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			oblform->exec();
			delete oblform;
			break;

		 // Integerized Sinusoid
		case 35:
			QMessageBox::information(this, "Sorry","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);

			projectionComboBox->setCurrentItem(0);

/*			intsineForm * isform;
			isform = new intsineForm(0,0,true,WINDOW_FLAGS);
			connect(isform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArrayOut(double*)));
			isform->exec();
			delete isform;
*/			break;
		}
	}
    }
}

// Function to check for a proper double in the pixel edit box
void mapimgForm::pixEditCheck()
{
    QString pixstring = pixelEdit->text();

    char cpixstring[200] = "";
    strncpy(cpixstring,pixstring,200);

    int i = 0;
    int decimals = 0;

    // check Pixel Edit Box for a "value"
    while ( //i < 200 &&
	cpixstring[i] != '\0')
    {
		// if digit found, proceed
		if(isdigit(cpixstring[i]))
		{
			i++;
		}

		// if decimal found, and only one decimal exists, proceed
		else if(cpixstring[i] == '.')
		{
			if(decimals < 1)
			{
				decimals++;
				i++;
			}
			else
			{
				pixelEdit->clear();
				break;
			}
		}

		// otherwise, delete contents from the edit box
		else
		{
			pixelEdit->clear();
			break;
		}
    }
}

// Function to selecct the desired input file
void mapimgForm::getInfile()
{
    // get the input file to MapIMG
    QString fileTypes = "MapIMG Generic Binary Files (*";
    fileTypes.append( defaultExtension );
    fileTypes.append( ");;Tiff Files (*.tif);;All Files (*.*)" );
    QString s = QFileDialog::getOpenFileName(
                    defaultInPath,
                    fileTypes,
                    this,
                    "open file dialog"
                    "Choose a file" );

    if( s == NULL ) return;   //cancel pressed
    // if output and input names the same, don't allow
    if( s == outfilepath )
    {
	QMessageBox::information (this, "Aborted!","Input and Output file names must be different!",
					QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	return;
    }


    if( QFile::exists( s ) && s.right( 3 ).upper() == "TIF" )
    {
	int reply = QMessageBox::information( this, "Convert?",
                                  "Tiff images can not be projected directly.\nWould you like to export to Generic Binary?",
				  QMessageBox::Yes, QMessageBox::No, QMessageBox::NoButton);
	if( reply == QMessageBox::Yes )
	{
            fileTypes = "MapIMG Generic Binary files (*";
            fileTypes.append( defaultExtension );
            fileTypes.append( ");;All Files (*.*)" );

            QString s2 = QFileDialog::getSaveFileName(
                         defaultInPath,
                         fileTypes,
                         this,
                         "save file dialog"
                         "Choose a filename to save under" );


            if( s2 == NULL ) return;   //cancel pressed

            //add defualt extension if none is provided
            if( (s2.find( '.' ) == -1 ) ) s2.append( defaultExtension );

            // if output and input names the same, don't allow
            if( (s2  && s2 == infilepath) || ( s2 && s2 == s ) )
            {
		QMessageBox::information (this, "Aborted!","Input and Output file names must be different!",
					QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
		return;
            }

            // if output file exists, ask about overwriting
            QString sinfo = s2;
            sinfo.append( ".info" );

            if( (s2  &&  QFile::exists(s2) )  || ( s2 && QFile::exists(sinfo) ) )
            {
                int answer = QMessageBox::warning(
                                this, "MapIMG -- Overwrite File",
                                QString( "Overwrite -- Process is Not Reversable\n\'%1\'?" ).
                                    arg( s2 ),
                                QMessageBox::Yes, QMessageBox::No, QMessageBox::NoButton );

                if( answer == QMessageBox::Yes)
                {
		    QString infodelete = s2 + ".info";
		    remove(s2);
		    remove(infodelete);
                }
                else
                    return;
            }

            if( tiff2img( s, s2 ) )
            {
		QMessageBox::information (this, "Complete","Coversion Complete",
					QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
                s = s2;
            }
	}
	else
            return;
    }

    if( QFile::exists( s ) )
    {
        QDir fileDir( s.left( s.findRev( "/" ) ));
        if( fileDir.absPath() != defaultInPath )
        {
            QSettings *settings = new QSettings( QSettings::Ini );
            settings->setPath( "USGS.gov", "MapIMG" );
            settings->writeEntry( "/USGS/MapIMG/DefaultInput", fileDir.absPath() );
            defaultInPath = settings->readEntry( "/USGS/MapIMG/DefaultInput" );
            delete settings;
        }

        QString inputInfoFile = s;
        loadInputInfo( inputInfoFile );
    }
    if(!s)
    {
	inputDataTypeComboBox->setCurrentItem(0);
	showAllDataTypes();
	inputProjectionComboBox->setCurrentItem(0);
    }
}

// Function to load all paramenters
void mapimgForm::loadInputInfo( QString &s )
{

    infilepath = s;

    inFilenameEdit->setText(s);
     //set initial conditions for dialog in case .info is not present
    inputDataTypeComboBox->setEnabled( true );
    showAllDataTypes();
    inputDataTypeComboBox->setCurrentItem( 0 );
    inputProjectionComboBox->setEnabled( true );
    inputProjectionComboBox->setCurrentItem( 0 );
    numRowsSpin->setValue( 0 );
    numColsSpin->setValue( 0 );


  //check for valid .info  (if found update dialog
  s.append( ".info" );
  if( QFile::exists( s ) )
  {
     //load .info file contents into dialog
     projInfo info( s );
     if( info.isValid() )
     {
         inputProjectionComboBox->setEnabled( false );
         numRowsSpin->setEnabled( false );
         numColsSpin->setEnabled( false );

         //set values based on .info
         numRowsSpin->setValue( info.getRows() );
         numColsSpin->setValue( info.getColumns() );

         //select proper data type
         QString bitSelection = info.getProjDataType();
         if( bitSelection != "Unknown" )
         {
             QString inputFilename = s;
             inputFilename.remove( ".info" );

             inputDataTypeComboBox->setCurrentText( bitSelection );
             inputDataTypeComboBox->setEnabled( false );

             int max_value = 0;

             if( bitSelection == "Unsigned 8 Bit" )
             {
               	 unsigned char ucType = 'U';
                 max_value = (int)get_max_value( inputFilename.ascii(),
                                                 info.getRows()*info.getColumns(),
                                                 ucType );
             }
             else if( bitSelection == "Signed 8 Bit" )
             {
              	 signed char scType = 'S';
                 max_value = (int)get_max_value( inputFilename.ascii(),
                                                 info.getRows()*info.getColumns(),
                                                 scType );
             }
             else if( bitSelection == "Unsigned 16 Bit" )
             {
               	 unsigned short usType = 0;
                 max_value = (int)get_max_value( inputFilename.ascii(),
                                                 info.getRows()*info.getColumns(),
                                                 usType );
             }
             else if( bitSelection == "Signed 16 Bit" )
             {
                 short sType = 0;
                 max_value = (int)get_max_value( inputFilename.ascii(),
                                                 info.getRows()*info.getColumns(),
                                                 sType );
             }
             else if( bitSelection == "IEEE 32 Bit Float" )
             {
               	float fType = 0.0;
                max_value = (int)get_max_value( inputFilename.ascii(),
                                                info.getRows()*info.getColumns(),
                                                fType );
             }
             else if( bitSelection == "Unsigned 32 Bit" )
             {
               	unsigned int uiType = 0;
                max_value = (int)get_max_value( inputFilename.ascii(),
                                                info.getRows()*info.getColumns(),
                                                uiType );
             }
             else if( bitSelection == "Signed 32 Bit" )
             {
       	        int iType = 0;
                max_value = (int)get_max_value( inputFilename.ascii(),
                                                info.getRows()*info.getColumns(),
                                                iType );
             }
             else if( bitSelection == "IEEE 64 Bit Float" )
             {
              	double dType = 0.0;
                max_value = (int)get_max_value( inputFilename.ascii(),
                                                info.getRows()*info.getColumns(),
                                                dType );
             }

            if( max_value > 0 )
            {
            	fillvalSpin->setValue( max_value + 2 );
            }
        }


         //select proper projection
         for( int index = 0; index < inputProjectionComboBox->count(); index++ )
              if( inputProjectionComboBox->text( index ) == info.getProjName() )
              {
                   inputProjectionComboBox->setCurrentItem( index );
                   break;
              }
     }

  }

  s.remove( ".info" );
}

// Function to select the desired output file
void mapimgForm::getOutfile()
{

    // get the output file to MapIMG
    QString fileTypes = "MapIMG Generic Binary files (*";
    fileTypes.append( defaultExtension );
    fileTypes.append( ");;All Files (*.*)" );

    QString s = QFileDialog::getSaveFileName(
                    defaultOutPath,
                    fileTypes,
                    this,
                    "save file dialog"
                    "Choose a filename to save under" );

    int answer = -1;
    if( s == NULL ) return;   //cancel pressed

    //add defualt extension if none is provided
    if( (s.find( '.' ) == -1 ) ) s.append( defaultExtension );

    // if output and input names the same, don't allow
    if(s  && s == infilepath)
    {
		QMessageBox::information (this, "Aborted!","Input and Output file names must be different!",
					QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
		return;
    }

    // if output file exists, ask about overwriting
    QString sinfo = s;
    sinfo.append( ".info" );

    if( s )
    {
        QDir fileDir( s.left( s.findRev( "/" ) ));
        if( fileDir.absPath() != defaultInPath )
        {
            QSettings *settings = new QSettings( QSettings::Ini );
            settings->setPath( "USGS.gov", "MapIMG" );
            settings->writeEntry( "/USGS/MapIMG/DefaultOutput", fileDir.absPath() );
            defaultOutPath = settings->readEntry( "/USGS/MapIMG/DefaultOutput" );
            delete settings;
        }
    }

    if( (s  &&  QFile::exists(s) )  || ( s && QFile::exists(sinfo) ) )
    {
                answer = QMessageBox::warning(
                                this, "MapIMG -- Overwrite File",
                                QString( "Overwrite -- Process is Not Reversable\n\'%1\'?" ).
                                    arg( s ),
                                "&Yes", "&No", QString::null, 1, 1 );
    }

    // if yes, remove generic binary and .info files to prepare for overwrite
    if(answer == 0)
    {
		QString infodelete = s + ".info";
		remove(s);
		remove(infodelete);
		outfilepath = s;
		outFilenameEdit->setText(s);
    }
    // if no overwrite needed
    else if(answer == -1)
    {
		outfilepath = s;
		outFilenameEdit->setText(s);
    }
    // otherwise, reset the path
    else
    {
    	        s = "";
		outfilepath = s;
		outFilenameEdit->setText(s);
		projectionComboBox->setCurrentItem(0);
    }

    return;
}


// Function to check the pixel combo box and assign the appropriate value
void mapimgForm::pixelCheck()
{
    double fivedeg = 555974.548395;		// pixel size for 5 degrees
    double onedeg = 111194.909679;		// pixel size for 1 degree
    double thirtymin = 55597.4548395;		// pixel size for 30 minutes
    double fivemin = 9266.24247325;		// pixel size for 5 minutes
    double thirtysec = 926.624247325;		// pixel size for 30 arc seconds


    // get current item in pixel combo box, if "---------", set back to original
    int index = pixelComboBox->currentItem();
    if(index < 2)
    {
		pixelEdit->setDisabled(true);
		pixelComboBox->setCurrentItem(0);
    }

    // otherwise, set the correct value in pixelSize
    // if other chosen, activate the other box
    else
    {
		switch(index)
		{
		case 2:
			pixelEdit->setDisabled(true);
			pixelSize = fivedeg;
			break;

		case 3:
			pixelEdit->setDisabled(true);
			pixelSize = onedeg;
			break;

		case 4:
			pixelEdit->setDisabled(true);
			pixelSize = thirtymin;
			break;

		case 5:
			pixelEdit->setDisabled(true);
			pixelSize = fivemin;
			break;

		case 6:
			pixelEdit->setDisabled(true);
			pixelSize = thirtysec;
			break;

		case 7:
			pixelEdit->setEnabled(true);
			break;
		}
    }
}

// Check for existing in.info file
bool mapimgForm::infilenameExist()
{
    QString s = infilepath + ".info";
    if(QFile::exists(s))
    {
	return true;
    }
    else
    {
	return false;
    }
}

// Check for existing out.info file
bool mapimgForm::outfilenameExist()
{
    QString s = outfilepath + ".info";
    if(QFile::exists(s))
    {
	return true;
    }
    else
    {
	return false;
    }
}

// Constructor to initialize
void mapimgForm::init()
{
    QString version = "v",
            major_version = "",
            minor_version = "",
            revision_version = "";

    major_version.setNum( MAJOR_VER );
    version += major_version;
    version += ".";
    minor_version.setNum( MINOR_VER );
    version += minor_version;
    version += ".";
    revision_version.setNum( REVISION_VER );
    version += revision_version;

    this->setCaption( caption() + "  " );
    this->setCaption( caption() + version );
    this->setIcon( qembed_findImage( "usgs" ) );

    infilepath = "";
    outfilepath = "";
    pixelSize = 0;
    inutmzone = 62;
    oututmzone = 62;
    input_gctparray = new double[15];
    Q_CHECK_PTR( input_gctparray );
    output_gctparray = new double[15];
    Q_CHECK_PTR( output_gctparray );
    for (int i = 0; i < 15; i++)
    {
	input_gctparray[i] = 0.0;
	output_gctparray[i] = 0.0;
    }

    QSettings *settings = new QSettings( QSettings::Ini );
    settings->setPath( "USGS.gov", "MapIMG" );


    defaultInPath = settings->readEntry( "/USGS/MapIMG/DefaultInput" );
    defaultOutPath = settings->readEntry( "/USGS/MapIMG/DefaultOutput" );

    if( defaultInPath == NULL || !QFile::exists( defaultInPath ) )
        settings->writeEntry( "/USGS/MapIMG/DefaultInput", QDir::currentDirPath() );
    if( defaultOutPath == NULL || !QFile::exists( defaultOutPath ) )
        settings->writeEntry( "/USGS/MapIMG/DefaultOutput", QDir::currentDirPath() );

    delete settings;
    
    QTimer *timer = new QTimer( this );
    connect( timer, SIGNAL(timeout()), this, SLOT(timerDone()) );
    timer->start( 300 );
}



// Function to update input gctparray
void mapimgForm::setgctpArray( double * ptr )
{
    for(int i = 0; i < 15; i++)
    {
	input_gctparray[i] = ptr[i];
    }
}

// Function to check input projection Combo Box
void mapimgForm::comboCheckIn()
{
    int index = inputProjectionComboBox->currentItem();
    if(index < 2)
    {
	inputProjectionComboBox->setCurrentItem(0);
    }
    if(index == 2)
    {
	numRowsSpin->setEnabled(true);
	numColsSpin->setEnabled(true);
    }
    else
    {
	numRowsSpin->setEnabled(false);
	numColsSpin->setEnabled(false);
	numRowsSpin->setValue(0);
	numColsSpin->setValue(0);
    }

    if(infilepath == "" || infilepath == " " || infilepath == NULL)
    {
	QMessageBox::information(this, "Aborted!","Please Select an Input File First!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
	inputProjectionComboBox->setCurrentItem(0);
    }

    else if(!infilenameExist())
    {
	             int s;

		switch(index)
		{
		 // UTM
		case 3:
		case 4:
		case 6:
		case 13:
		case 16:
		             s = QMessageBox::information(this, "Sorry!","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
			inputProjectionComboBox->setCurrentItem(0);

/*			utmForm * utmform;
			utmform = new utmForm(0,0,true,WINDOW_FLAGS);
			connect(utmform, SIGNAL(changesMade(double *, int)), this, SLOT(setUTMin(double *, int)));
			utmform->exec();
			delete utmform;
*/			break;

		 // Albers Equal Area, (Lambert Conformal Conic), Equidistant Conic B
		case 5:
//		case 6:
		case 11:
			lambForm * lambform;
			lambform = new lambForm(0,0,true,WINDOW_FLAGS);
			connect(lambform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        lambform->getGCTP();
			connect(lambform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			lambform->exec();
			delete lambform;
			if( index == 11)
			{
			    input_gctparray[8] = 1;
			}
			break;

		 // Mercator
		case 7:
			mercForm * mercform;
			mercform = new mercForm(0,0,true,WINDOW_FLAGS);
			connect(mercform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        mercform->getGCTP();
			connect(mercform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			mercform->exec();
			delete mercform;
			break;

		 // Polar Stereographic
		case 8:
			s = QMessageBox::information(this, "Sorry!","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
			inputProjectionComboBox->setCurrentItem(0);

/*			psForm * psform;
			psform = new psForm(0,0,true,WINDOW_FLAGS);
			connect(psform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			psform->exec();
			delete psform;
*/			break;

		 // Polyconic
		case 9:
			pcForm * pcform;
			pcform = new pcForm(0,0,true,WINDOW_FLAGS);
			connect(pcform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        pcform->getGCTP();
			connect(pcform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			pcform->exec();
			delete pcform;
			break;

		 // Equidistant Conic A
		case 10:
			ecaForm * ecaform;
			ecaform = new ecaForm(0,0,true,WINDOW_FLAGS);
			connect(ecaform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        ecaform->getGCTP();
			connect(ecaform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			ecaform->exec();
			delete ecaform;
			break;

		 // Transverse Mercator
		case 12:
			tmercForm * tmercform;
			tmercform = new tmercForm(0,0,true,WINDOW_FLAGS);
			connect(tmercform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        tmercform->getGCTP();
			connect(tmercform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			tmercform->exec();
			delete tmercform;
			break;

		 // (Stereographic), Lambert Azimuthal, Azimuthal, (Gnomonic), Orthographic
//		case 13:
		case 14:
		case 15:
//		case 16:
		case 17:
			stereoForm * sterform;
			sterform = new stereoForm(0,0,true,WINDOW_FLAGS);
			connect(sterform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        sterform->getGCTP();
			connect(sterform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			sterform->exec();
			delete sterform;
			break;

		 // Gen. Vert. Near Per
		case 18:
			genVertForm * genform;
			genform = new genVertForm(0,0,true,WINDOW_FLAGS);
			connect(genform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        genform->getGCTP();
			connect(genform, SIGNAL(changesMade(double *)), this, SLOT(setgctpArray(double *)));
			genform->exec();
			delete genform;
			break;

		 // Sinusoidal, Miller Cylindrical, Robinson, Mollweide, Hammer, Wagner IV, Wagner VII
		case 19:
		case 21:
		case 25:
		case 30:
		case 32:
		case 33:
		case 34:
			sineForm * sineform;
			sineform = new sineForm(0,0,true,WINDOW_FLAGS);
			connect(sineform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        sineform->getGCTP();
			connect(sineform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			sineform->exec();
			delete sineform;
			break;

		 // Equirectangular
		case 20:
			equirectForm * equiform;
			equiform = new equirectForm(0,0,true,WINDOW_FLAGS);
			connect(equiform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        equiform->getGCTP();
			connect(equiform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			equiform->exec();
			delete equiform;
			break;

		 // Van der Grinten
		case 22:
			vanderForm * vandform;
			vandform = new vanderForm(0,0,true,WINDOW_FLAGS);
			connect(vandform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        vandform->getGCTP();
			connect(vandform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			vandform->exec();
			delete vandform;
			break;

		 // Hotin Oblique Mercator A
		case 23:
			homaForm * homaform;
			homaform = new homaForm(0,0,true,WINDOW_FLAGS);
			connect(homaform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        homaform->getGCTP();
			connect(homaform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			homaform->exec();
			delete homaform;
			break;

		 // Hotin Oblique Mercator B
		case 24:
			hombForm * hombform;
			hombform = new hombForm(0,0,true,WINDOW_FLAGS);
			connect(hombform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        hombform->getGCTP();
			connect(hombform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			hombform->exec();
			delete hombform;
			break;

		 // Space Oblique Mercator A
		case 26:
			somaForm * somaform;
			somaform = new somaForm(0,0,true,WINDOW_FLAGS);
			connect(somaform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        somaform->getGCTP();
			connect(somaform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			somaform->exec();
			delete somaform;
			break;

		 // Space Oblique Mercator B
		case 27:
			sombForm * sombform;
			sombform = new sombForm(0,0,true,WINDOW_FLAGS);
			connect(sombform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        sombform->getGCTP();
			connect(sombform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			sombform->exec();
			delete sombform;
			break;

		 // Alaska Conformal
		case 28:
			s = QMessageBox::information(this, "Sorry!","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
			inputProjectionComboBox->setCurrentItem(0);

/*			acForm * acform;
			acform = new acForm(0,0,true,WINDOW_FLAGS);
			connect(acform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			acform->exec();
			delete acform;
*/			break;

		 // Interrupted Mollweide, Interrupted Goode
		case 29:
		case 31:
			interruptForm * interform;
			interform = new interruptForm(0,0,true,WINDOW_FLAGS);
			connect(interform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        interform->getGCTP();
			connect(interform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			interform->exec();
			delete interform;
			break;

		 // Oblated Equal Area
		case 35:
			oblatedForm * oblform;
			oblform = new oblatedForm(0,0,true,WINDOW_FLAGS);
			connect(oblform, SIGNAL(getGCTP(double*)), this, SLOT(getInputGCTP(double*)));
                        oblform->getGCTP();
			connect(oblform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			oblform->exec();
			delete oblform;
			break;

		 // Integerized Sinusoid
		case 36:
			s = QMessageBox::information(this, "Sorry!","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
			inputProjectionComboBox->setCurrentItem(0);

/*			intsineForm * isform;
			isform = new intsineForm(0,0,true,WINDOW_FLAGS);
			connect(isform, SIGNAL(changesMade(double*)), this, SLOT(setgctpArray(double*)));
			isform->exec();
			delete isform;
*/			break;
		}
    }
    else if(index == 3 || index == 4 || index == 6 || index == 8 || index == 13 || index == 16 || index == 28 || index == 36)
    {
		QMessageBox::information(this, "Sorry!","This projection is not currently supported!!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
		inputProjectionComboBox->setCurrentItem(0);
    }
}


// Function to update output gctp array
void mapimgForm::setgctpArrayOut( double * ptr )
{
   for(int i = 0; i < 15; i++)
    {
	output_gctparray[i] = ptr[i];
    }
}

// Function to update input pixel size
void mapimgForm::setInPixel( double pixel )
{
    inPixelSize = pixel;
}


void mapimgForm::setUTMout( double * ptr, int val )
{
    for(int i = 0; i < 15; i++)
    {
	output_gctparray[i] = ptr[i];
    }
    oututmzone = val;
}


void mapimgForm::setUTMin( double * ptr, int val )
{
    for(int i = 0; i < 15; i++)
    {
	input_gctparray[i] = ptr[i];
    }
    inutmzone = val;
}


void mapimgForm::setSPout( int val )
{
    outspunit = val;
}

void mapimgForm::infileValid( const QString& infileName )
{
 if(QFile::exists(infileName))
 {
    infilepath = infileName;
 }
}

void mapimgForm::outfileValid( const QString& outfileName )
{
     outfilepath = outfileName;
}


//calculate which data types to show in inputDataTypeComboBox
void mapimgForm::calcDataType()
{
     Q_ULONG ulSize = 0;
     int rowCount = numRowsSpin->value(),
         colCount = numColsSpin->value();

     if( QFile::exists( infilepath ))
     {
         QFile qfFile( infilepath );
         ulSize = qfFile.size();
         if( ulSize == (Q_ULONG)( rowCount*colCount ) )
             show8BitDataTypes();
         else if( ulSize == (Q_ULONG)( rowCount*colCount*2 ) )
             show16BitDataTypes();
         else if( ulSize == (Q_ULONG)( rowCount*colCount*4 ) )
             show32BitDataTypes();
         else if( ulSize == (Q_ULONG)( rowCount*colCount*8 ) )
             show64BitDataTypes();
         else
         {
             showAllDataTypes();
             inputDataTypeComboBox->setEnabled( true );
         }
     }
     else
     {
         inputDataTypeComboBox->setCurrentItem( 0 );
         inputDataTypeComboBox->setEnabled( true );
         showAllDataTypes();
     }

     return;
}


void mapimgForm::comboCheckData()
{
     int index = inputDataTypeComboBox->currentItem();
     if(index < 2)
     {
		inputDataTypeComboBox->setCurrentItem(0);
     }

     if(infilepath == "" || infilepath == " " || infilepath == NULL)
     {
	        QMessageBox::information(this, "Aborted!","Please Select an Input File First!",
				        QMessageBox::Ok, QMessageBox::NoButton, QMessageBox::NoButton);
		inputDataTypeComboBox->setCurrentItem(0);
    }

}

//Adjust inputDataTypeComboBox to show all supported
//       bit data types
void mapimgForm::showAllDataTypes()
{
     QString qsCurrentText = inputDataTypeComboBox->currentText();

     inputDataTypeComboBox->clear();
     inputDataTypeComboBox->insertItem( "Select Image Data Type" );
     inputDataTypeComboBox->insertItem( "------------------------------" );
     inputDataTypeComboBox->insertItem( "Unsigned 8 Bit" );
     inputDataTypeComboBox->insertItem( "Signed 8 Bit" );
     inputDataTypeComboBox->insertItem( "Unsigned 16 Bit" );
     inputDataTypeComboBox->insertItem( "Signed 16 Bit" );
     inputDataTypeComboBox->insertItem( "Unsigned 32 Bit" );
     inputDataTypeComboBox->insertItem( "Signed 32 Bit" );
     inputDataTypeComboBox->insertItem( "IEEE 32 Bit Float" );
     inputDataTypeComboBox->insertItem( "IEEE 64 Bit Float" );

     inputDataTypeComboBox->setCurrentText( qsCurrentText );
}


//Adjust inputDataTypeComboBox to show only supported
//       8 bit data types
void mapimgForm::show8BitDataTypes()
{
     //Store current selection to help user, by selecting respective data type
     //      after adjust box contents
     QString qsCurrentText = inputDataTypeComboBox->currentText();

     //Clear contents and add only 8 bit data types
     inputDataTypeComboBox->clear();
     inputDataTypeComboBox->insertItem( "Select Image Data Type" );
     inputDataTypeComboBox->insertItem( "------------------------------" );
     inputDataTypeComboBox->insertItem( "Unsigned 8 Bit" );
     inputDataTypeComboBox->insertItem( "Signed 8 Bit" );

     //Select related data type to user's previous selection
     //       or set to initial state
     if( qsCurrentText.left( 8 ) == "Unsigned" )
         inputDataTypeComboBox->setCurrentItem( 2 );
     else if( qsCurrentText.left( 6 ) == "Signed" )
         inputDataTypeComboBox->setCurrentItem( 3 );
     else
         inputDataTypeComboBox->setCurrentItem( 0 );
}


//Adjust inputDataTypeComboBox to show only supported
//       16 bit data types
void mapimgForm::show16BitDataTypes()
{
     //Store current selection to help user, by selecting respective data type
     //      after adjust box contents
     QString qsCurrentText = inputDataTypeComboBox->currentText();

     //Clear contents and add only 16 bit data types
     inputDataTypeComboBox->clear();
     inputDataTypeComboBox->insertItem( "Select Image Data Type" );
     inputDataTypeComboBox->insertItem( "------------------------------" );
     inputDataTypeComboBox->insertItem( "Unsigned 16 Bit" );
     inputDataTypeComboBox->insertItem( "Signed 16 Bit" );

     //Select related data type to user's previous selection
     //       or set to initial state
     if( qsCurrentText.left( 8 ) == "Unsigned" )
         inputDataTypeComboBox->setCurrentItem( 2 );
     else if( qsCurrentText.left( 6 ) == "Signed" )
         inputDataTypeComboBox->setCurrentItem( 3 );
     else
         inputDataTypeComboBox->setCurrentItem( 0 );
}

//Adjust inputDataTypeComboBox to show only supported
//       32 bit data types
void mapimgForm::show32BitDataTypes()
{
     //Store current selection to help user, by selecting respective data type
     //      after adjust box contents
     QString qsCurrentText = inputDataTypeComboBox->currentText();

     //Clear contents and add only 32 bit data types
     inputDataTypeComboBox->clear();
     inputDataTypeComboBox->insertItem( "Select Image Data Type" );
     inputDataTypeComboBox->insertItem( "------------------------------" );
     inputDataTypeComboBox->insertItem( "Unsigned 32 Bit" );
     inputDataTypeComboBox->insertItem( "Signed 32 Bit" );
     inputDataTypeComboBox->insertItem( "IEEE 32 Bit Float" );

     //Select related data type to user's previous selection
     //       or set to initial state
     if( qsCurrentText.left( 8 ) == "Unsigned" )
         inputDataTypeComboBox->setCurrentItem( 2 );
     else if( qsCurrentText.left( 6 ) == "Signed" )
         inputDataTypeComboBox->setCurrentItem( 3 );
     else if( qsCurrentText.left( 4 ) == "IEEE" )
         inputDataTypeComboBox->setCurrentItem( 4 );
     else
         inputDataTypeComboBox->setCurrentItem( 0 );

}


//Adjust inputDataTypeComboBox to show only supported
//       64 bit data types
void mapimgForm::show64BitDataTypes()
{
     //Store current selection to help user, by selecting respective data type
     //      after adjust box contents
     QString qsCurrentText = inputDataTypeComboBox->currentText();

     //Clear contents and add only 64 bit data types
     inputDataTypeComboBox->clear();
     inputDataTypeComboBox->insertItem( "Select Image Data Type" );
     inputDataTypeComboBox->insertItem( "------------------------------" );
     inputDataTypeComboBox->insertItem( "IEEE 64 Bit Float" );

     //Select related data type to user's previous selection
     //       or set to initial state
     if( qsCurrentText.left( 4 ) == "IEEE" )
         inputDataTypeComboBox->setCurrentItem( 2 );
     else
         inputDataTypeComboBox->setCurrentItem( 0 );

}

//fill elements of ptr with the elements in the output_gctparray
//  used by forms to fill dialogs
//  ptr MUST be declared 15 element double
//  i.e   double array[15];       getOutputGCTP( array );
void mapimgForm::getOutputGCTP( double * ptr )
{
     for( int i = 0; i < 15; i++ )
     {
          ptr[i] = output_gctparray[i];
     }

     return;
}

//fill elements of ptr with the elements in the input_gctparray
//  used by forms to fill dialogs
//  ptr MUST be declared 15 element double
//  i.e   double array[15];       of array = new double[15];
void mapimgForm::getInputGCTP( double * ptr )
{
     for( int i = 0; i < 15; i++ )
     {
          ptr[i] = input_gctparray[i];
     }

     return;
}

//Detects what's this mode and shows about dialog
void mapimgForm::timerDone()
{
     if( QWhatsThis::inWhatsThisMode() )
     {
     	 QWhatsThis::leaveWhatsThisMode();
         showAboutMapIMG();
     }
}


void mapimgForm::mousePressEvent( QMouseEvent * e )
{
   if( e->button() == Qt::RightButton )
   {
       QPopupMenu *aboutPopup = new QPopupMenu( this, "AboutPopup" );
       aboutPopup->insertItem( tr("About MapIMG"), this, SLOT(showAboutMapIMG()) );
       aboutPopup->insertSeparator();
       aboutPopup->insertItem( tr("About Qt"), this, SLOT(showAboutQt()) );

       aboutPopup->exec( QCursor::pos() );

       delete aboutPopup;
   }
}


void mapimgForm::showAboutMapIMG()
{
     aboutForm *aboutform = new aboutForm( NULL, "aboutform", false,
                                           Qt::WStyle_Customize | Qt::WStyle_NormalBorder );
     aboutform->exec();
	 delete aboutform;
}


void mapimgForm::showAboutQt()
{
     QMessageBox::aboutQt( this );
}
